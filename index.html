<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uhrzeit â€“ Umgangssprache (Sprechen)</title>
  <style>
    :root{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:#f3f4f6;}
    body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:14px;}
    .app{background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.1);padding:1.6rem 1.4rem;max-width:590px;width:100%;box-sizing:border-box;}
    h1{margin:0 0 .4rem;text-align:center;font-size:1.6rem;}
    .subtitle{text-align:center;color:#4b5563;margin-bottom:1rem;font-size:.95rem;}
    .hidden{display:none;}
    .center{text-align:center;}
    .choice-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:.6rem;margin:.7rem 0 .4rem;}
    .choice-btn{padding:.9rem .6rem;border-radius:16px;border:2px solid #d1d5db;background:#f9fafb;font-size:1rem;font-weight:650;cursor:pointer;}
    .choice-btn.selected{background:#2563eb;color:#fff;border-color:#1d4ed8;box-shadow:0 5px 15px rgba(37,99,235,.35);}
    .selected-info{font-size:.85rem;color:#6b7280;text-align:center;min-height:1.2rem;margin:.2rem 0 .3rem;}
    .primary-btn{margin-top:.8rem;width:100%;padding:.75rem 1rem;font-size:1.1rem;border:none;border-radius:999px;cursor:pointer;background:#2563eb;color:#fff;font-weight:800;}
    .primary-btn:disabled{background:#9ca3af;cursor:not-allowed;}
    .secondary-btn{margin-top:.4rem;width:100%;padding:.65rem 1rem;font-size:1rem;border-radius:999px;border:1px solid #d1d5db;cursor:pointer;background:#f9fafb;color:#111827;font-weight:700;}
    .progress{text-align:center;color:#6b7280;font-size:.9rem;margin-bottom:.4rem;}
    .tag{display:inline-block;border-radius:999px;padding:.15rem .6rem;font-size:.8rem;background:#eff6ff;color:#1d4ed8;}
    .clock-wrapper{display:flex;justify-content:center;margin-top:.6rem;}
    #clock-canvas{background:#f9fafb;border-radius:50%;box-shadow:inset 0 0 5px rgba(0,0,0,.08);}
    .answer-box{margin-top:1rem;border:1px solid #e5e7eb;background:#f9fafb;border-radius:14px;padding:.9rem;}
    .equation{text-align:center;margin:.4rem 0 .2rem;font-size:1.05rem;color:#111827;font-weight:800;}
    .mic-row{display:grid;grid-template-columns:1fr;gap:.6rem;margin-top:.6rem;}
    @media (min-width:520px){.mic-row{grid-template-columns:1fr 1fr;}}
    .mic-btn{width:100%;padding:.75rem 1rem;font-size:1.05rem;border-radius:999px;border:none;cursor:pointer;font-weight:900;background:#111827;color:#fff;}
    .mic-btn.listening{background:#dc2626;}
    .mic-btn:disabled{background:#9ca3af;cursor:not-allowed;}
    .input-fallback{width:100%;padding:.7rem .8rem;border-radius:12px;border:2px solid #d1d5db;background:#fff;font-size:1.02rem;font-weight:700;color:#111827;outline:none;box-sizing:border-box;}
    .heard{margin-top:.6rem;font-size:.95rem;color:#374151;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:.6rem .7rem;min-height:2.2rem;word-break:break-word;}
    .hint{font-size:.85rem;color:#6b7280;margin-top:.5rem;line-height:1.35;}
    .feedback{min-height:1.4rem;margin-top:.6rem;font-weight:850;text-align:center;}
    .feedback.ok{color:#15803d;}
    .feedback.error{color:#b91c1c;}
    .stats{margin-top:.9rem;font-size:.95rem;color:#374151;}
    .badge{display:inline-block;padding:.15rem .55rem;border-radius:999px;font-size:.78rem;border:1px solid #e5e7eb;background:#fff;color:#374151;}
  </style>
</head>
<body>
<div class="app">
  <h1>Wie spÃ¤t ist es?</h1>
  <div class="subtitle">
    Lies die analoge Uhr und sage die Uhrzeit in Umgangssprache.<br>
    Muster: <strong>punkt</strong>, <strong>fÃ¼nf nach</strong>, <strong>zehn nach</strong>, <strong>viertel nach</strong>, <strong>zwanzig nach</strong>,
    <strong>fÃ¼nf vor halb</strong>, <strong>halb</strong>, <strong>fÃ¼nf nach halb</strong>,
    <strong>zwanzig vor</strong>, <strong>viertel vor</strong>, <strong>zehn vor</strong>, <strong>fÃ¼nf vor</strong> + Stunde.
  </div>

  <div id="start-screen">
    <div class="center"><p>Bitte eine <strong>Klasse</strong> und eine <strong>Schwierigkeit</strong> auswÃ¤hlen.</p></div>
    <div class="center" style="margin-top:.5rem;">Klasse</div>
    <div class="choice-grid" id="grade-grid">
      <button type="button" class="choice-btn grade-btn" data-grade="2">2. Klasse</button>
      <button type="button" class="choice-btn grade-btn" data-grade="3">3. Klasse</button>
    </div>
    <div class="center" style="margin-top:1rem;">Schwierigkeit</div>
    <div class="choice-grid" id="difficulty-grid">
      <button type="button" class="choice-btn difficulty-btn" data-diff="easy">einfach</button>
      <button type="button" class="choice-btn difficulty-btn" data-diff="hard">schwierig</button>
    </div>
    <div class="selected-info" id="selected-info"></div>
    <button class="primary-btn" id="start-btn" disabled>Los!</button>
    <div class="hint center" id="sr-note"></div>
  </div>

  <div id="quiz-screen" class="hidden">
    <div class="progress" id="progress-text"></div>
    <div class="center">
      <span class="tag" id="variant-label"></span>
      <div class="equation">Sage die passende Uhrzeit:</div>
      <div class="hint"><span class="badge">Wichtig</span> Wir generieren aus den Rohdaten nur erlaubte Muster (siehe oben) und prÃ¼fen nur diese.</div>
    </div>

    <div class="clock-wrapper">
      <canvas id="clock-canvas" width="220" height="220"></canvas>
    </div>

    <div class="answer-box">
      <div class="mic-row">
        <button class="mic-btn" id="mic-btn">ðŸŽ¤ Sprechen</button>
        <button class="secondary-btn" id="check-btn" style="margin-top:0;">ÃœberprÃ¼fen</button>
      </div>

      <div id="fallback-wrap" class="hidden" style="margin-top:.6rem;">
        <input id="fallback-input" class="input-fallback" placeholder="Falls Sprechen nicht geht: hier eintippen (z.B. fÃ¼nf vor halb vier)" />
        <div class="hint">Browser ohne Spracherkennung: tippe. (Chrome/Edge empfohlen)</div>
      </div>

      <div class="heard" id="heard-raw">Rohdaten: â€”</div>
      <div class="heard" id="heard-gen" style="margin-top:.4rem;">Gefundenes Muster: â€”</div>

      <div class="feedback" id="feedback"></div>
      <div class="hint" id="expected-hint"></div>
    </div>

    <div class="stats">
      Richtig: <span id="stat-correct">0</span> / <span id="stat-total">30</span><br>
      Falsche Versuche: <span id="stat-wrong">0</span><br>
      Modus: <span id="stat-mode"></span>
    </div>
  </div>

  <div id="result-screen" class="hidden center">
    <h2>Fertig! ðŸŽ‰</h2>
    <p id="result-summary"></p>
    <p style="margin-top:.8rem; font-size:.9rem; color:#4b5563;">
      Wenn du fertig bist, klicke auf <strong>â€žFertigâ€œ</strong>, damit LearningView den Auftrag als erledigt markiert.
    </p>
    <button class="primary-btn" id="finish-btn">Fertig</button>
    <button class="secondary-btn" id="restart-btn">Weiter Ã¼ben</button>
  </div>
</div>

<script>
  // ==========================
  // Konfiguration
  // ==========================
  const TOTAL_QUESTIONS = 30;
  const GRADE_LABELS = { 2: "2. Klasse", 3: "3. Klasse" };
  const DIFF_LABELS  = { easy: "einfach", hard: "schwierig" };
  const SUPPORTED_MINUTES = [0,5,10,15,20,25,30,35,40,45,50,55];

  // Erlaubte Muster (genau diese Strings + Stunde)
  const PATTERNS = [
    "punkt",
    "fÃ¼nf nach",
    "zehn nach",
    "viertel nach",
    "zwanzig nach",
    "fÃ¼nf vor halb",
    "halb",
    "fÃ¼nf nach halb",
    "zwanzig vor",
    "viertel vor",
    "zehn vor",
    "fÃ¼nf vor"
  ];

  const HOURS = ["eins","zwei","drei","vier","fÃ¼nf","sechs","sieben","acht","neun","zehn","elf","zwÃ¶lf"];
  const HOUR_ALIASES = {
    "1":"eins","2":"zwei","3":"drei","4":"vier","5":"fÃ¼nf","6":"sechs","7":"sieben","8":"acht","9":"neun","10":"zehn","11":"elf","12":"zwÃ¶lf","0":"zwÃ¶lf",
    "ein":"eins" // fÃ¼rs Parsing; fÃ¼rs Ausgeben machen wir spÃ¤ter "ein uhr" nicht nÃ¶tig
  };

  // ==========================
  // State
  // ==========================
  let selectedGrade=null, selectedDifficulty=null;
  let questionsDone=0, correctAnswers=0, wrongAnswers=0;
  let usedQuestions=[];
  let currentQuestion=null;

  let lastRaw = "";
  let lastGenerated = ""; // das extrahierte/erzeugte Muster, das geprÃ¼ft wird

  // ==========================
  // DOM
  // ==========================
  const startScreen = document.getElementById("start-screen");
  const quizScreen = document.getElementById("quiz-screen");
  const resultScreen = document.getElementById("result-screen");

  const gradeGrid = document.getElementById("grade-grid");
  const difficultyGrid = document.getElementById("difficulty-grid");
  const selectedInfo = document.getElementById("selected-info");
  const startBtn = document.getElementById("start-btn");
  const srNote = document.getElementById("sr-note");

  const progressText = document.getElementById("progress-text");
  const variantLabel = document.getElementById("variant-label");
  const heardRawEl = document.getElementById("heard-raw");
  const heardGenEl = document.getElementById("heard-gen");
  const feedback = document.getElementById("feedback");
  const expectedHint = document.getElementById("expected-hint");

  const statCorrect = document.getElementById("stat-correct");
  const statTotal = document.getElementById("stat-total");
  const statWrong = document.getElementById("stat-wrong");
  const statMode = document.getElementById("stat-mode");

  const restartBtn = document.getElementById("restart-btn");
  const finishBtn = document.getElementById("finish-btn");
  const resultSummary = document.getElementById("result-summary");

  const micBtn = document.getElementById("mic-btn");
  const checkBtn = document.getElementById("check-btn");
  const fallbackWrap = document.getElementById("fallback-wrap");
  const fallbackInput = document.getElementById("fallback-input");

  const clockCanvas = document.getElementById("clock-canvas");
  const clockCtx = clockCanvas.getContext("2d");

  // ==========================
  // Helpers
  // ==========================
  function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function capFirst(s){ return s ? s.charAt(0).toUpperCase()+s.slice(1) : s; }

  function hourToWord(h){
    const map={1:"eins",2:"zwei",3:"drei",4:"vier",5:"fÃ¼nf",6:"sechs",7:"sieben",8:"acht",9:"neun",10:"zehn",11:"elf",12:"zwÃ¶lf"};
    return map[h] || String(h);
  }

  function numberToGerman(n){
    const ones=["null","eins","zwei","drei","vier","fÃ¼nf","sechs","sieben","acht","neun"];
    const special={10:"zehn",11:"elf",12:"zwÃ¶lf",13:"dreizehn",14:"vierzehn",15:"fÃ¼nfzehn",16:"sechzehn",17:"siebzehn",18:"achtzehn",19:"neunzehn"};
    if(n>=0 && n<=9) return ones[n];
    if(n>=10 && n<=19) return special[n];
    const tensMap={20:"zwanzig",30:"dreiÃŸig",40:"vierzig",50:"fÃ¼nfzig"};
    const tens=Math.floor(n/10)*10;
    const one=n%10;
    if(one===0) return tensMap[tens] || String(n);
    const oneWord = (one===1) ? "ein" : ones[one];
    return oneWord + "und" + (tensMap[tens] || String(tens));
  }

  function padNorm(s){
    return (" " + s + " ").replace(/\s+/g," ");
  }

  // ==========================
  // 1) Erwartete LÃ¶sung aus Zeit erzeugen (GENAU deine Umgangssprache)
  // ==========================
  function expectedPhraseFromTime(hour, minute){
    const h = ((hour - 1) % 12) + 1;
    const next = (h % 12) + 1;
    const hw = hourToWord(h);
    const nhw = hourToWord(next);

    if(minute===0)  return `punkt ${hw}`;            // statt "ein uhr" -> "punkt eins" etc.
    if(minute===5)  return `fÃ¼nf nach ${hw}`;
    if(minute===10) return `zehn nach ${hw}`;
    if(minute===15) return `viertel nach ${hw}`;
    if(minute===20) return `zwanzig nach ${hw}`;
    if(minute===25) return `fÃ¼nf vor halb ${nhw}`;
    if(minute===30) return `halb ${nhw}`;
    if(minute===35) return `fÃ¼nf nach halb ${nhw}`;
    if(minute===40) return `zwanzig vor ${nhw}`;
    if(minute===45) return `viertel vor ${nhw}`;
    if(minute===50) return `zehn vor ${nhw}`;
    if(minute===55) return `fÃ¼nf vor ${nhw}`;

    // fallback (sollte nicht passieren)
    return `punkt ${hw}`;
  }

  // ==========================
  // 2) Rohdaten -> erlaubte Muster extrahieren/generieren
  //    (nur PATTERNS + Stunde)
  // ==========================
  function normalizeRawToSearchable(raw){
    raw = (raw||"").toLowerCase();

    // hÃ¤ufige Zusammenziehungen
    raw = raw
      .replace(/\bvorhalb\b/g,"vor halb")
      .replace(/\bnachhalb\b/g,"nach halb")
      .replace(/\bviertal\b/g,"viertel")       // Tippfehler / SR-Fehler
      .replace(/\bviertl\b/g,"viertel")
      .replace(/\bviatel\b/g,"viertel");

    // Zeiten wie 7:35, 10.25 etc. â†’ wir lassen sie drin und parsen separat
    // Einzelne Zahlen â†’ ZahlwÃ¶rter (damit "5 vor halb 4" funktioniert)
    raw = raw.replace(/\b(\d{1,2})\b/g, (_,d)=>numberToGerman(parseInt(d,10)));

    // FÃ¼llwÃ¶rter lÃ¶schen (aber NICHTS umformulieren)
    raw = raw
      .replace(/\bes\s+ist\b/g," ")
      .replace(/\bdas\s+ist\b/g," ")
      .replace(/\bbitte\b/g," ")
      .replace(/\bjetzt\b/g," ")
      .replace(/\buhr\b/g," ")
      .replace(/\bgenau\b/g," ")
      .replace(/\s+/g," ")
      .trim();

    // Nur Buchstaben + ":" "." + Leerzeichen behalten (fÃ¼r Zeitformate)
    raw = raw.replace(/[^\p{L}\s:.\d]/gu," ").replace(/\s+/g," ").trim();

    return raw;
  }

  function parseTimeToken(raw){
    // 7:35 / 10:25 / 7.35
    const m = raw.match(/\b([0-2]?\d)\s*[:.]\s*([0-5]\d)\b/);
    if(!m) return null;
    let hh = parseInt(m[1],10);
    let mm = parseInt(m[2],10);
    if(!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
    if(hh===0) hh=12;
    hh = ((hh-1)%12)+1;
    return {hour: hh, minute: mm};
  }

  function extractAllowedPhrasesFromRaw(raw){
    const out = [];

    const clean = normalizeRawToSearchable(raw);
    if(!clean) return out;

    // A) Wenn eine Uhrzeit als 7:35 vorkommt -> direkt in Phrase wandeln
    const t = parseTimeToken(clean);
    if(t && SUPPORTED_MINUTES.includes(t.minute)){
      out.push(expectedPhraseFromTime(t.hour, t.minute));
    }

    // B) Muster + Stunde in Worten suchen
    // Wir suchen explizit nur diese Kombinationen.
    // Wichtig: Stunde kann als "ein" kommen -> wir mappen auf "eins"
    let text = clean
      .replace(/\beins\b/g,"eins")
      .replace(/\bein\b/g,"eins"); // fÃ¼r "ein" als Stunde (falls SR so liefert)

    const padded = padNorm(text);

    // Hilfsfunktion: finde Stunde hinter pattern
    function tryMatch(pattern){
      const p = pattern.replace(/\s+/g," ").trim();
      // pattern + hour (eins..zwÃ¶lf)
      for(const hw of HOURS){
        const needle = " " + p + " " + hw + " ";
        if(padded.includes(needle)){
          out.push(p + " " + hw);
          return true;
        }
      }
      return false;
    }

    // PrioritÃ¤t: lÃ¤ngere Muster zuerst, sonst matcht "fÃ¼nf vor" bevor "fÃ¼nf vor halb"
    const patternsByLength = [...PATTERNS].sort((a,b)=>b.length-a.length);

    // Spezial: "punkt" + Stunde
    // Wir akzeptieren auch nur "elf" ohne "punkt" als Stunde â†’ wird zu "punkt elf"
    // (weil du "elf" / "zwei" explizit erwÃ¤hnt hast)
    let foundAny = false;

    for(const pat of patternsByLength){
      if(pat === "punkt"){
        // 1) "punkt <stunde>"
        for(const hw of HOURS){
          const needle = " punkt " + hw + " ";
          if(padded.includes(needle)){
            out.push("punkt " + hw);
            foundAny = true;
            break;
          }
        }
      } else {
        if(tryMatch(pat)) foundAny = true;
      }
    }

    // C) Wenn nur eine Stunde gesagt wurde: "eins".."zwÃ¶lf" â†’ als "punkt <stunde>"
    if(!foundAny){
      for(const hw of HOURS){
        const needle = " " + hw + " ";
        if(padded.includes(needle)){
          out.push("punkt " + hw);
          break;
        }
      }
    }

    // Duplikate entfernen, Reihenfolge behalten
    return [...new Set(out.map(s=>s.replace(/\s+/g," ").trim()))];
  }

  // ==========================
  // 3) Auswahl: welche der gefundenen Phrasen nehmen wir?
  //    -> wir wÃ¤hlen die, die zur aktuellen Aufgabe passt, sonst erste
  // ==========================
  function chooseBestCandidate(candidates){
    if(!candidates.length) return "";
    if(!currentQuestion) return candidates[0];

    const expected = currentQuestion.expected; // string
    const expPadded = padNorm(expected);

    // perfekter Treffer
    for(const c of candidates){
      if(padNorm(c) === expPadded) return c;
    }

    // sonst: wenn pattern passt (z.B. "fÃ¼nf vor halb") und Stunde passt
    const expHour = expected.split(" ").slice(-1)[0];
    const expPrefix = expected.split(" ").slice(0,-1).join(" ");

    // 1) gleicher Prefix und Stunde
    for(const c of candidates){
      const parts = c.split(" ");
      const cHour = parts[parts.length-1];
      const cPrefix = parts.slice(0,-1).join(" ");
      if(cHour === expHour && cPrefix === expPrefix) return c;
    }

    // 2) gleicher Prefix
    for(const c of candidates){
      const parts = c.split(" ");
      const cPrefix = parts.slice(0,-1).join(" ");
      if(cPrefix === expPrefix) return c;
    }

    // 3) fallback
    return candidates[0];
  }

  // ==========================
  // SpeechRecognition
  // ==========================
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recognizer=null, isListening=false;

  function setupSpeechRecognition(){
    if(!SR){
      recognizer=null;
      micBtn.disabled=true;
      micBtn.textContent="ðŸŽ¤ Nicht verfÃ¼gbar";
      fallbackWrap.classList.remove("hidden");
      srNote.textContent="Spracherkennung funktioniert am zuverlÃ¤ssigsten in Chrome/Edge.";
      return;
    }
    recognizer = new SR();
    recognizer.lang = "de-DE";
    recognizer.interimResults = false;
    recognizer.continuous = false;
    recognizer.maxAlternatives = 1;

    recognizer.onstart = () => {
      isListening=true;
      micBtn.classList.add("listening");
      micBtn.textContent="â¹ Stop";
      heardRawEl.textContent="Rohdaten: â€¦";
      heardGenEl.textContent="Gefundenes Muster: â€¦";
      feedback.textContent="";
      feedback.className="feedback";
    };

    recognizer.onend = () => {
      isListening=false;
      micBtn.classList.remove("listening");
      micBtn.textContent="ðŸŽ¤ Sprechen";
    };

    recognizer.onerror = (e) => {
      feedback.textContent="Sprach-Fehler: " + (e.error || "unbekannt");
      feedback.className="feedback error";
      fallbackWrap.classList.remove("hidden");
    };

    recognizer.onresult = (e) => {
      const raw = (e.results?.[0]?.[0]?.transcript || "").trim();
      lastRaw = raw;

      const cands = extractAllowedPhrasesFromRaw(raw);
      lastGenerated = chooseBestCandidate(cands);

      heardRawEl.textContent = "Rohdaten: " + (lastRaw || "â€”");
      heardGenEl.textContent = "Gefundenes Muster: " + (lastGenerated || "â€”");
    };

    srNote.textContent="Mikrofon erlauben, dann â€žSprechenâ€œ klicken. (Chrome/Edge empfohlen)";
  }

  // ==========================
  // UI (Start / Result)
  // ==========================
  gradeGrid.querySelectorAll(".grade-btn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const g = Number(btn.dataset.grade);
      selectedGrade = (selectedGrade===g) ? null : g;
      gradeGrid.querySelectorAll(".grade-btn").forEach(b=>b.classList.toggle("selected", Number(b.dataset.grade)===selectedGrade));
      updateStartControls();
    });
  });
  difficultyGrid.querySelectorAll(".difficulty-btn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const d = btn.dataset.diff;
      selectedDifficulty = (selectedDifficulty===d) ? null : d;
      difficultyGrid.querySelectorAll(".difficulty-btn").forEach(b=>b.classList.toggle("selected", b.dataset.diff===selectedDifficulty));
      updateStartControls();
    });
  });

  function updateStartControls(){
    if(!selectedGrade){ selectedInfo.textContent="Bitte eine Klasse auswÃ¤hlen."; startBtn.disabled=true; return; }
    if(!selectedDifficulty){ selectedInfo.textContent="Bitte eine Schwierigkeit auswÃ¤hlen."; startBtn.disabled=true; return; }
    selectedInfo.textContent = `AusgewÃ¤hlt: ${GRADE_LABELS[selectedGrade]}, ${DIFF_LABELS[selectedDifficulty]}`;
    startBtn.disabled = false;
  }

  startBtn.addEventListener("click", startTraining);
  restartBtn.addEventListener("click", ()=>{
    quizScreen.classList.add("hidden");
    resultScreen.classList.add("hidden");
    startScreen.classList.remove("hidden");
  });

  finishBtn.addEventListener("click", ()=>{
    finishBtn.disabled=true;
    finishBtn.textContent="Erledigt âœ”";
    try{
      if(window.parent && window.parent !== window){
        window.parent.postMessage("AppSolved","*");
      }
    }_unpack(()=>{});
  });

  micBtn.addEventListener("click", ()=>{
    if(!recognizer){ fallbackWrap.classList.remove("hidden"); return; }
    if(isListening){ try{ recognizer.stop(); }catch(_){ } return; }
    try{
      lastRaw=""; lastGenerated="";
      recognizer.start();
    }catch(_){
      feedback.textContent="Bitte kurz warten und nochmals klicken.";
      feedback.className="feedback error";
    }
  });

  checkBtn.addEventListener("click", checkAnswer);
  fallbackInput.addEventListener("keydown",(e)=>{
    if(e.key==="Enter"){ e.preventDefault(); checkAnswer(); }
  });

  // ==========================
  // Quiz Logic
  // ==========================
  function startTraining(){
    questionsDone=0; correctAnswers=0; wrongAnswers=0; usedQuestions=[];
    statCorrect.textContent="0";
    statWrong.textContent="0";
    statTotal.textContent=String(TOTAL_QUESTIONS);
    statMode.textContent=`${GRADE_LABELS[selectedGrade]} â€“ ${DIFF_LABELS[selectedDifficulty]}`;

    feedback.textContent="";
    feedback.className="feedback";
    heardRawEl.textContent="Rohdaten: â€”";
    heardGenEl.textContent="Gefundenes Muster: â€”";
    expectedHint.textContent="";

    startScreen.classList.add("hidden");
    resultScreen.classList.add("hidden");
    quizScreen.classList.remove("hidden");

    newQuestion();
  }

  function generateTimeQuestion(grade, diff){
    const hour = randomInt(1,12);
    let minute = 0;
    let label = "";

    if(grade===2 && diff==="easy"){
      minute = pick([0,30]);
      label = "Volle & halbe Stunden";
    } else if(grade===2 && diff==="hard"){
      minute = pick([0,5,10,15,20,25,30,35,40,45,50,55]);
      label = "Umgangssprache Mix";
    } else {
      minute = pick(SUPPORTED_MINUTES);
      label = (diff==="easy") ? "5-Minuten-Schritte" : "5-Minuten-Schritte (Mix)";
    }

    const expected = expectedPhraseFromTime(hour, minute); // string
    return { hour, minute, label, expected };
  }

  function newQuestion(){
    feedback.textContent="";
    feedback.className="feedback";
    lastRaw=""; lastGenerated="";
    fallbackInput.value="";
    heardRawEl.textContent="Rohdaten: â€”";
    heardGenEl.textContent="Gefundenes Muster: â€”";

    let q, tries=0;
    while(true){
      q = generateTimeQuestion(selectedGrade, selectedDifficulty);
      const key = `${q.hour}-${q.minute}-${selectedGrade}-${selectedDifficulty}`;
      if(!usedQuestions.includes(key)){ usedQuestions.push(key); break; }
      if(++tries > 500) break;
    }

    currentQuestion = q;
    variantLabel.textContent = q.label;
    drawClock(q.hour, q.minute);
    progressText.textContent = `Aufgabe ${questionsDone+1} von ${TOTAL_QUESTIONS}`;
    expectedHint.textContent = "Beispiel richtig: " + q.expected;
  }

  function checkAnswer(){
    // wenn nicht gesprochen: typed -> auch Ã¼ber den gleichen Generator laufen lassen
    let gen = lastGenerated;
    if(!gen){
      const typed = (fallbackInput.value||"").trim();
      const cands = extractAllowedPhrasesFromRaw(typed);
      gen = chooseBestCandidate(cands);
      lastGenerated = gen;
      heardGenEl.textContent = "Gefundenes Muster: " + (gen || "â€”");
    }

    if(!gen){
      feedback.textContent="Ich finde kein gÃ¼ltiges Uhrzeit-Muster (nur die erlaubten Kombinationen werden geprÃ¼ft).";
      feedback.className="feedback error";
      return;
    }

    const ok = (gen === currentQuestion.expected);

    if(ok){
      correctAnswers++;
      statCorrect.textContent=String(correctAnswers);
      feedback.textContent="Richtig! ðŸ‘";
      feedback.className="feedback ok";
    } else {
      wrongAnswers++;
      statWrong.textContent=String(wrongAnswers);
      feedback.textContent="Falsch. Richtig wÃ¤re: " + currentQuestion.expected;
      feedback.className="feedback error";
    }

    questionsDone++;
    if(questionsDone>=TOTAL_QUESTIONS) setTimeout(endTraining, 700);
    else setTimeout(newQuestion, 700);
  }

  function endTraining(){
    quizScreen.classList.add("hidden");
    resultScreen.classList.remove("hidden");
    const quote = (correctAnswers/TOTAL_QUESTIONS*100).toFixed(0);
    resultSummary.innerHTML =
      `Du hast <strong>${TOTAL_QUESTIONS}</strong> Uhrzeiten gelÃ¶st.<br>`+
      `Richtig: <strong>${correctAnswers}</strong> (${quote}%).<br>`+
      `Falsch: <strong>${wrongAnswers}</strong>.`;
  }

  // ==========================
  // Clock: Striche, keine Zahlen, roter Stundenzeiger, blauer Minutenzeiger
  // ==========================
  function drawClock(hour, minute){
    const ctx=clockCtx;
    const w=clockCanvas.width, h=clockCanvas.height;
    const r=Math.min(w,h)/2-10;
    const cx=w/2, cy=h/2;

    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(cx,cy);

    // Face
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.fillStyle="#ffffff";
    ctx.fill();
    ctx.lineWidth=3;
    ctx.strokeStyle="#111827";
    ctx.stroke();

    // Ticks (60)
    for(let i=0;i<60;i++){
      const a=(Math.PI/30)*i - Math.PI/2;
      const isHour=(i%5===0);
      const outer=r-6;
      const inner=r-(isHour?18:12);

      ctx.beginPath();
      ctx.moveTo(inner*Math.cos(a), inner*Math.sin(a));
      ctx.lineTo(outer*Math.cos(a), outer*Math.sin(a));
      ctx.lineWidth=isHour?3:1.2;
      ctx.strokeStyle="#111827";
      ctx.stroke();
    }

    // Minute hand (blue)
    const ma=(Math.PI/30)*minute - Math.PI/2;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo((r-22)*Math.cos(ma), (r-22)*Math.sin(ma));
    ctx.lineWidth=4;
    ctx.strokeStyle="#2563eb";
    ctx.lineCap="round";
    ctx.stroke();

    // Hour hand (red)
    const ha=(Math.PI/6)*((hour%12)+minute/60) - Math.PI/2;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo((r-55)*Math.cos(ha), (r-55)*Math.sin(ha));
    ctx.lineWidth=5;
    ctx.strokeStyle="#dc2626";
    ctx.lineCap="round";
    ctx.stroke();

    // Center
    ctx.beginPath();
    ctx.arc(0,0,5,0,Math.PI*2);
    ctx.fillStyle="#111827";
    ctx.fill();

    ctx.restore();
  }

  // ==========================
  // Init
  // ==========================
  (function init(){
    statTotal.textContent=String(TOTAL_QUESTIONS);
    drawClock(12,0);
    setupSpeechRecognition();
    updateStartControls();
  })();
</script>
</body>
</html>
