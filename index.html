<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uhrzeit ‚Äì Umgangssprache (Sprechen)</title>
  <style>
    :root{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:#f3f4f6;}
    body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:14px;}
    .app{background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.1);padding:1.6rem 1.4rem;max-width:560px;width:100%;box-sizing:border-box;}
    h1{margin:0 0 .4rem;text-align:center;font-size:1.6rem;}
    .subtitle{text-align:center;color:#4b5563;margin-bottom:1rem;font-size:.95rem;}
    .hidden{display:none;}
    .center{text-align:center;}
    .choice-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:.6rem;margin:.7rem 0 .4rem;}
    .choice-btn{padding:.9rem .6rem;border-radius:16px;border:2px solid #d1d5db;background:#f9fafb;font-size:1rem;font-weight:600;cursor:pointer;transition:background .15s, transform .05s, border-color .15s, box-shadow .15s;}
    .choice-btn.selected{background:#2563eb;color:#fff;border-color:#1d4ed8;box-shadow:0 5px 15px rgba(37,99,235,.35);}
    .choice-btn:active{transform:translateY(1px);}
    .selected-info{font-size:.85rem;color:#6b7280;text-align:center;min-height:1.2rem;margin:.2rem 0 .3rem;}
    .primary-btn{margin-top:.8rem;width:100%;padding:.75rem 1rem;font-size:1.1rem;border:none;border-radius:999px;cursor:pointer;background:#2563eb;color:#fff;font-weight:700;}
    .primary-btn:hover{background:#1d4ed8;}
    .primary-btn:disabled{background:#9ca3af;cursor:not-allowed;}
    .secondary-btn{margin-top:.4rem;width:100%;padding:.65rem 1rem;font-size:1rem;border-radius:999px;border:1px solid #d1d5db;cursor:pointer;background:#f9fafb;color:#111827;font-weight:600;}
    .secondary-btn:hover{background:#e5e7eb;border-color:#9ca3af;}
    .progress{text-align:center;color:#6b7280;font-size:.9rem;margin-bottom:.4rem;}
    .tag{display:inline-block;border-radius:999px;padding:.15rem .6rem;font-size:.8rem;background:#eff6ff;color:#1d4ed8;}
    .clock-wrapper{display:flex;justify-content:center;margin-top:.6rem;}
    #clock-canvas{background:#f9fafb;border-radius:50%;box-shadow:inset 0 0 5px rgba(0,0,0,.08);}
    .answer-box{margin-top:1rem;border:1px solid #e5e7eb;background:#f9fafb;border-radius:14px;padding:.9rem;}
    .equation{text-align:center;margin:.4rem 0 .2rem;font-size:1.05rem;color:#111827;font-weight:700;}
    .mic-row{display:grid;grid-template-columns:1fr;gap:.6rem;margin-top:.6rem;}
    @media (min-width:520px){.mic-row{grid-template-columns:1fr 1fr;}}
    .mic-btn{width:100%;padding:.75rem 1rem;font-size:1.05rem;border-radius:999px;border:none;cursor:pointer;font-weight:800;background:#111827;color:#fff;}
    .mic-btn.listening{background:#dc2626;}
    .mic-btn:disabled{background:#9ca3af;cursor:not-allowed;}
    .input-fallback{width:100%;padding:.7rem .8rem;border-radius:12px;border:2px solid #d1d5db;background:#fff;font-size:1.02rem;font-weight:650;color:#111827;outline:none;box-sizing:border-box;}
    .input-fallback:focus{border-color:#2563eb;box-shadow:0 0 0 3px rgba(37,99,235,.15);}
    .heard{margin-top:.6rem;font-size:.95rem;color:#374151;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:.6rem .7rem;min-height:2.2rem;word-break:break-word;}
    .hint{font-size:.85rem;color:#6b7280;margin-top:.5rem;line-height:1.35;}
    .feedback{min-height:1.4rem;margin-top:.6rem;font-weight:750;text-align:center;}
    .feedback.ok{color:#15803d;}
    .feedback.error{color:#b91c1c;}
    .stats{margin-top:.9rem;font-size:.95rem;color:#374151;}
    .small-note{font-size:.85rem;color:#6b7280;margin-top:.4rem;}
    .badge{display:inline-block;padding:.15rem .55rem;border-radius:999px;font-size:.78rem;border:1px solid #e5e7eb;background:#fff;color:#374151;}
  </style>
</head>
<body>
<div class="app">
  <h1>Wie sp√§t ist es?</h1>
  <div class="subtitle">
    Lies die analoge Uhr und sage die Uhrzeit in Umgangssprache.<br>
    Beispiele: ‚ÄûViertel vor Zehn‚Äú, ‚ÄûF√ºnf nach Zwei‚Äú, ‚ÄûHalb Neun‚Äú, ‚ÄûEin Uhr‚Äú.
  </div>

  <div id="start-screen">
    <div class="center">
      <p>Bitte eine <strong>Klasse</strong> und eine <strong>Schwierigkeit</strong> ausw√§hlen.</p>
    </div>

    <div class="center" style="margin-top:.5rem;">Klasse</div>
    <div class="choice-grid" id="grade-grid">
      <button type="button" class="choice-btn grade-btn" data-grade="2">2. Klasse</button>
      <button type="button" class="choice-btn grade-btn" data-grade="3">3. Klasse</button>
    </div>

    <div class="center" style="margin-top:1rem;">Schwierigkeit</div>
    <div class="choice-grid" id="difficulty-grid">
      <button type="button" class="choice-btn difficulty-btn" data-diff="easy">einfach</button>
      <button type="button" class="choice-btn difficulty-btn" data-diff="hard">schwierig</button>
    </div>

    <div class="selected-info" id="selected-info"></div>
    <button class="primary-btn" id="start-btn" disabled>Los!</button>
    <div class="small-note center" id="sr-note"></div>
  </div>

  <div id="quiz-screen" class="hidden">
    <div class="progress" id="progress-text"></div>
    <div class="center">
      <span class="tag" id="variant-label"></span>
      <div class="equation">Sage die passende Uhrzeit:</div>
      <div class="small-note"><span class="badge">Regel</span> Wir wandeln die Erkennung immer zuerst in <strong>W√∂rter</strong> um und pr√ºfen dann.</div>
    </div>

    <div class="clock-wrapper">
      <canvas id="clock-canvas" width="220" height="220"></canvas>
    </div>

    <div class="answer-box">
      <div class="mic-row">
        <button class="mic-btn" id="mic-btn">üé§ Sprechen</button>
        <button class="secondary-btn" id="check-btn" style="margin-top:0;">√úberpr√ºfen</button>
      </div>

      <div id="fallback-wrap" class="hidden" style="margin-top:.6rem;">
        <input id="fallback-input" class="input-fallback" placeholder="Falls Sprechen nicht geht: hier eintippen (z.B. f√ºnf vor halb neun)" />
        <div class="hint">Browser ohne Spracherkennung: tippe die Antwort. (Empfohlen: Chrome/Edge)</div>
      </div>

      <div class="heard" id="heard">Erkannt: ‚Äî</div>
      <div class="feedback" id="feedback"></div>
      <div class="hint" id="expected-hint"></div>
    </div>

    <div class="stats">
      Richtig: <span id="stat-correct">0</span> / <span id="stat-total">30</span><br>
      Falsche Versuche: <span id="stat-wrong">0</span><br>
      Modus: <span id="stat-mode"></span>
    </div>
  </div>

  <div id="result-screen" class="hidden center">
    <h2>Fertig! üéâ</h2>
    <p id="result-summary"></p>
    <p style="margin-top:.8rem; font-size:.9rem; color:#4b5563;">
      Wenn du fertig bist, klicke auf <strong>‚ÄûFertig‚Äú</strong>, damit LearningView den Auftrag als erledigt markiert.
    </p>
    <button class="primary-btn" id="finish-btn">Fertig</button>
    <button class="secondary-btn" id="restart-btn">Weiter √ºben</button>
  </div>
</div>

<script>
  // ==========================
  // Konfiguration
  // ==========================
  const TOTAL_QUESTIONS = 30;
  const GRADE_LABELS = { 2: "2. Klasse", 3: "3. Klasse" };
  const DIFF_LABELS  = { easy: "einfach", hard: "schwierig" };
  const SUPPORTED_MINUTES = [0,5,10,15,20,25,30,35,40,45,50,55];

  // ==========================
  // State
  // ==========================
  let selectedGrade = null;
  let selectedDifficulty = null;
  let questionsDone = 0, correctAnswers = 0, wrongAnswers = 0;
  let usedQuestions = [];
  let currentQuestion = null;

  // Das ist der einzige Text, den wir pr√ºfen: IMMER W√∂rter
  let lastHeardWords = "";

  // ==========================
  // DOM
  // ==========================
  const startScreen = document.getElementById("start-screen");
  const quizScreen = document.getElementById("quiz-screen");
  const resultScreen = document.getElementById("result-screen");

  const gradeGrid = document.getElementById("grade-grid");
  const difficultyGrid = document.getElementById("difficulty-grid");
  const selectedInfo = document.getElementById("selected-info");
  const startBtn = document.getElementById("start-btn");
  const srNote = document.getElementById("sr-note");

  const progressText = document.getElementById("progress-text");
  const variantLabel = document.getElementById("variant-label");
  const heardEl = document.getElementById("heard");
  const feedback = document.getElementById("feedback");
  const expectedHint = document.getElementById("expected-hint");

  const statCorrect = document.getElementById("stat-correct");
  const statTotal = document.getElementById("stat-total");
  const statWrong = document.getElementById("stat-wrong");
  const statMode = document.getElementById("stat-mode");

  const restartBtn = document.getElementById("restart-btn");
  const finishBtn = document.getElementById("finish-btn");
  const resultSummary = document.getElementById("result-summary");

  const micBtn = document.getElementById("mic-btn");
  const checkBtn = document.getElementById("check-btn");
  const fallbackWrap = document.getElementById("fallback-wrap");
  const fallbackInput = document.getElementById("fallback-input");

  const clockCanvas = document.getElementById("clock-canvas");
  const clockCtx = clockCanvas.getContext("2d");

  // ==========================
  // Utils
  // ==========================
  function randomInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function capFirst(s){ return s ? s.charAt(0).toUpperCase()+s.slice(1) : s; }

  function hourToWord(h){
    const map = {1:"eins",2:"zwei",3:"drei",4:"vier",5:"f√ºnf",6:"sechs",7:"sieben",8:"acht",9:"neun",10:"zehn",11:"elf",12:"zw√∂lf"};
    return map[h] || String(h);
  }
  function hourToWordEin(h){ return h === 1 ? "ein" : hourToWord(h); }

  function numberToGerman(n){
    const ones = ["null","eins","zwei","drei","vier","f√ºnf","sechs","sieben","acht","neun"];
    const special = {10:"zehn",11:"elf",12:"zw√∂lf",13:"dreizehn",14:"vierzehn",15:"f√ºnfzehn",16:"sechzehn",17:"siebzehn",18:"achtzehn",19:"neunzehn"};
    if(n>=0 && n<=9) return ones[n];
    if(n>=10 && n<=19) return special[n];
    const tensMap = {20:"zwanzig",30:"drei√üig",40:"vierzig",50:"f√ºnfzig"};
    const tens = Math.floor(n/10)*10;
    const one = n%10;
    if(one===0) return tensMap[tens] || String(n);
    const oneWord = (one===1) ? "ein" : ones[one];
    return oneWord + "und" + (tensMap[tens] || String(tens));
  }

  function parseAnyTime(raw){
    raw = (raw || "").toLowerCase();

    // 9:05 / 9.05 / 09:05
    let m = raw.match(/\b([0-2]?\d)\s*[:.]\s*([0-5]\d)\b/);
    if(m){
      let hh = parseInt(m[1],10), mm = parseInt(m[2],10);
      if(!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
      if(hh===0) hh=12;
      hh = ((hh-1)%12)+1;
      return {hour: hh, minute: mm};
    }

    // "11 uhr" / "punkt 2 uhr"
    m = raw.match(/\b(punkt\s*)?([0-2]?\d)\s*uhr\b/);
    if(m){
      let hh = parseInt(m[2],10);
      if(!Number.isFinite(hh)) return null;
      if(hh===0) hh=12;
      hh = ((hh-1)%12)+1;
      return {hour: hh, minute: 0};
    }

    // "9 05"
    m = raw.match(/\b([0-2]?\d)\s+([0-5]\d)\b/);
    if(m){
      let hh = parseInt(m[1],10), mm = parseInt(m[2],10);
      if(!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
      if(hh===0) hh=12;
      hh = ((hh-1)%12)+1;
      return {hour: hh, minute: mm};
    }

    return null;
  }

  function timeToCanonicalWords(h, m){
    const nextH = (h % 12) + 1;
    const hw = hourToWord(h);
    const nhw = hourToWord(nextH);

    if(m === 0)  return `${hourToWordEin(h)} uhr`;
    if(m === 5)  return `f√ºnf nach ${hw}`;
    if(m === 10) return `zehn nach ${hw}`;
    if(m === 15) return `viertel nach ${hw}`;
    if(m === 20) return `zwanzig nach ${hw}`;
    if(m === 25) return `f√ºnf vor halb ${nhw}`;
    if(m === 30) return `halb ${nhw}`;
    if(m === 35) return `f√ºnf nach halb ${nhw}`;
    if(m === 40) return `zwanzig vor ${nhw}`;
    if(m === 45) return `viertel vor ${nhw}`;
    if(m === 50) return `zehn vor ${nhw}`;
    if(m === 55) return `f√ºnf vor ${nhw}`;
    return "";
  }

  // ======= WICHTIG: vor halb / nach halb werden hart normalisiert =======
  function normalizeHeardToClockWords(raw){
    raw = (raw || "").toLowerCase();

    // 0) H√§ufige Verschmelzungen/Fehltrennungen abfangen:
    // "vorhalb" -> "vor halb", "nachhalb" -> "nach halb"
    raw = raw
      .replace(/\bvorhalb\b/g, "vor halb")
      .replace(/\bnachhalb\b/g, "nach halb");

    // 1) Wenn Zeit als Ziffern erkennbar: ersetze durch kanonische W√∂rter
    const parsed = parseAnyTime(raw);
    if(parsed){
      const phrase = timeToCanonicalWords(parsed.hour, parsed.minute);
      if(phrase) raw = phrase;
    }

    // 2) Standalone Zahlen zu W√∂rtern (5 vor halb 9 etc.)
    raw = raw.replace(/\b(\d{1,2})\b/g, (_, d) => numberToGerman(parseInt(d,10)));

    // 3) F√ºllw√∂rter raus, "punkt" und "uhr" ignorieren
    raw = raw
      .replace(/\bes\s+ist\b/g," ")
      .replace(/\bdas\s+ist\b/g," ")
      .replace(/\bjetzt\b/g," ")
      .replace(/\bbitte\b/g," ")
      .replace(/\b√§h\b/g," ")
      .replace(/\bhm\b/g," ")
      .replace(/\balso\b/g," ")
      .replace(/\buhr\b/g," ")
      .replace(/\bpunkt\b/g," ");

    // 4) Nur Buchstaben/Spaces behalten
    raw = raw.replace(/[^\p{L}\s]/gu," ").replace(/\s+/g," ").trim();

    // 5) "eins" -> "ein" (aber akzeptieren beide sp√§ter trotzdem)
    raw = raw.replace(/\beins\b/g,"ein").replace(/\s+/g," ").trim();

    // 6) Stelle sicher, dass "f√ºnf vor halb" / "f√ºnf nach halb" als exakte Phrase steht,
    // falls SR komisch trennt (z.B. "f√ºnf vorhalb").
    raw = raw
      .replace(/\bf√ºnf\s+vor\s+halb\b/g, "f√ºnf vor halb")
      .replace(/\bf√ºnf\s+nach\s+halb\b/g, "f√ºnf nach halb");

    return raw;
  }

  function containsPhrase(heard, phrase){
    const H = " " + heard + " ";
    const P = " " + phrase + " ";
    return H.includes(P);
  }

  function getExpectedHourWordsFromCanonical(canonical){
    const words = (canonical || "")
      .toLowerCase()
      .replace(/[^\p{L}\s]/gu," ")
      .split(/\s+/)
      .filter(Boolean);

    const hours = new Set(["ein","eins","zwei","drei","vier","f√ºnf","sechs","sieben","acht","neun","zehn","elf","zw√∂lf"]);
    const found = words.filter(w => hours.has(w));
    if(found.length === 0) return null;
    const last = found[found.length-1];
    if(last === "ein" || last === "eins") return ["ein","eins"];
    return [last];
  }

  function buildAcceptedPhrasesNormalized(canonical){
    const base = normalizeHeardToClockWords(canonical);
    const set = new Set([base]);

    // ein/eins
    set.add(base.replace(/\bein\b/g,"eins"));
    set.add(base.replace(/\beins\b/g,"ein"));

    // F√ºr Sicherheit: manche SR liefern "f√ºnf vorhalb"
    // -> wir haben im Normalize schon vorhalb->vor halb, aber akzeptieren zur Not noch roh:
    set.add(base.replace(/\bvor halb\b/g,"vorhalb"));
    set.add(base.replace(/\bnach halb\b/g,"nachhalb"));

    return Array.from(set).map(s => s.replace(/\s+/g," ").trim());
  }

  function buildAcceptedPhrasesRawForGrammar(canonical){
    const base = (canonical || "").toLowerCase().replace(/\buhr\b/g,"").trim();

    const set = new Set([base, base.replace(/\bein\b/g,"eins"), base.replace(/\beins\b/g,"ein")]);

    // Exakt diese 2 Phrasen aggressiv rein (dein Wunsch):
    set.add("f√ºnf vor halb");
    set.add("f√ºnf nach halb");
    set.add("fuenf vor halb");
    set.add("fuenf nach halb");

    // Falls SR zusammenzieht:
    set.add("f√ºnf vorhalb");
    set.add("f√ºnf nachhalb");
    set.add("fuenf vorhalb");
    set.add("fuenf nachhalb");

    // Wrapper
    const out = new Set();
    for(const p of set){
      out.add(p);
      out.add("es ist " + p);
      out.add(p + " uhr");
      out.add("es ist " + p + " uhr");
    }
    return Array.from(out);
  }

  // ==========================
  // SpeechRecognition: Grammar + Best Alternative
  // ==========================
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  const SGL = window.SpeechGrammarList || window.webkitSpeechGrammarList;

  let recognizer = null;
  let isListening = false;

  function buildJSGFForQuestion(q){
    // Wir erzwingen "f√ºnf vor halb" / "f√ºnf nach halb" im Grammar-Universum.
    // Zus√§tzlich lassen wir die komplette erwartete Phrase zu (z.B. "f√ºnf vor halb drei").
    const fixed = [
      "es ist",
      "uhr","punkt",
      "ein","eins","zwei","drei","vier","f√ºnf","sechs","sieben","acht","neun","zehn","elf","zw√∂lf",
      "f√ºnf nach","zehn nach","viertel nach","zwanzig nach",
      "f√ºnf vor","zehn vor","viertel vor","zwanzig vor",
      "halb",
      "f√ºnf vor halb","f√ºnf nach halb",
      "fuenf vor halb","fuenf nach halb",
      "f√ºnf vorhalb","f√ºnf nachhalb",
      "fuenf vorhalb","fuenf nachhalb"
    ];

    const choices = Array.from(new Set([...fixed, ...(q.acceptedPhrasesRaw || [])]));
    return `#JSGF V1.0; grammar time; public <time> = (${choices.join(" | ")});`;
  }

  function setGrammarForCurrentQuestion(){
    if(!recognizer || !SGL || !currentQuestion) return;
    try{
      const gl = new SGL();
      gl.addFromString(buildJSGFForQuestion(currentQuestion), 1);
      recognizer.grammars = gl;
    }catch(_){
      // ignore if unsupported
    }
  }

  function pickBestFromResult(e){
    const expected = currentQuestion?.acceptedPhrases || [];
    const expHours = currentQuestion?.expectedHourWords || null;

    let best = "";
    let bestScore = -1;

    const alts = e.results?.[0] || [];
    for(let i=0;i<alts.length;i++){
      const raw = alts[i].transcript || "";
      const words = normalizeHeardToClockWords(raw);
      if(!words) continue;

      let score = 0;

      // HARTE PRIORIT√ÑT: wenn Aufgabe "vor halb" / "nach halb" ist, MUSS das im Heard vorkommen
      const expectsHalfComplex = expected.some(p => p.includes("vor halb") || p.includes("nach halb"));
      if(expectsHalfComplex){
        const hasMarker = (words.includes("vor halb") || words.includes("nach halb") || words.includes("vorhalb") || words.includes("nachhalb"));
        if(!hasMarker) score -= 1000; // f√§llt fast immer raus
      }

      // gro√üer Treffer: enth√§lt erwartete Phrase
      for(const exp of expected){
        if(containsPhrase(words, exp)) score = Math.max(score, 100);
      }

      // Bonus: enth√§lt erwartete Stundenw√∂rter (gegen 3/6 Drift)
      if(expHours){
        for(const h of expHours){
          if(containsPhrase(words, h)) score += 10;
        }
      }

      // Mini-Strafe f√ºr sehr lange S√§tze
      score -= Math.min(words.length, 60) * 0.05;

      if(score > bestScore){
        bestScore = score;
        best = words;
      }
    }

    if(!best){
      const raw0 = e.results?.[0]?.[0]?.transcript || "";
      best = normalizeHeardToClockWords(raw0);
    }
    return best;
  }

  function setupSpeechRecognition(){
    if(!SR){
      recognizer = null;
      micBtn.disabled = true;
      micBtn.textContent = "üé§ Nicht verf√ºgbar";
      fallbackWrap.classList.remove("hidden");
      srNote.textContent = "Hinweis: Spracherkennung funktioniert am zuverl√§ssigsten in Chrome/Edge.";
      return;
    }

    recognizer = new SR();

    // de-DE ist in Chrome meist stabiler als de-CH
    recognizer.lang = "de-DE";

    recognizer.interimResults = false;
    recognizer.continuous = false;

    // Mehr Alternativen -> wir w√§hlen die beste passende
    recognizer.maxAlternatives = 10;

    recognizer.onstart = () => {
      isListening = true;
      micBtn.classList.add("listening");
      micBtn.textContent = "‚èπ Stop";
      heardEl.textContent = "Erkannt: ‚Ä¶";
      feedback.textContent = "";
      feedback.className = "feedback";
    };

    recognizer.onend = () => {
      isListening = false;
      micBtn.classList.remove("listening");
      micBtn.textContent = "üé§ Sprechen";
    };

    recognizer.onerror = (e) => {
      feedback.textContent = "Sprach-Fehler: " + (e.error || "unbekannt");
      feedback.className = "feedback error";
      fallbackWrap.classList.remove("hidden");
    };

    recognizer.onresult = (e) => {
      lastHeardWords = pickBestFromResult(e);
      heardEl.textContent = "Erkannt: " + (lastHeardWords || "‚Äî");
    };

    srNote.textContent = "Mikrofon erlauben, dann ‚ÄûSprechen‚Äú klicken. (Chrome/Edge empfohlen)";
  }

  // ==========================
  // Flow
  // ==========================
  gradeGrid.querySelectorAll(".grade-btn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const g = Number(btn.dataset.grade);
      selectedGrade = (selectedGrade === g) ? null : g;
      gradeGrid.querySelectorAll(".grade-btn").forEach(b=>{
        b.classList.toggle("selected", Number(b.dataset.grade) === selectedGrade);
      });
      updateStartControls();
    });
  });

  difficultyGrid.querySelectorAll(".difficulty-btn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const d = btn.dataset.diff;
      selectedDifficulty = (selectedDifficulty === d) ? null : d;
      difficultyGrid.querySelectorAll(".difficulty-btn").forEach(b=>{
        b.classList.toggle("selected", b.dataset.diff === selectedDifficulty);
      });
      updateStartControls();
    });
  });

  function updateStartControls(){
    if(!selectedGrade){ selectedInfo.textContent = "Bitte eine Klasse ausw√§hlen."; startBtn.disabled = true; return; }
    if(!selectedDifficulty){ selectedInfo.textContent = "Bitte eine Schwierigkeit ausw√§hlen."; startBtn.disabled = true; return; }
    selectedInfo.textContent = `Ausgew√§hlt: ${GRADE_LABELS[selectedGrade]}, ${DIFF_LABELS[selectedDifficulty]}`;
    startBtn.disabled = false;
  }

  startBtn.addEventListener("click", startTraining);

  restartBtn.addEventListener("click", ()=>{
    quizScreen.classList.add("hidden");
    resultScreen.classList.add("hidden");
    startScreen.classList.remove("hidden");
  });

  finishBtn.addEventListener("click", ()=>{
    finishBtn.disabled = true;
    finishBtn.textContent = "Erledigt ‚úî";
    try{
      if(window.parent && window.parent !== window){
        window.parent.postMessage("AppSolved","*");
      }
    }catch(_){}
  });

  micBtn.addEventListener("click", ()=>{
    if(!recognizer){ fallbackWrap.classList.remove("hidden"); return; }
    if(isListening){ try{ recognizer.stop(); }catch(_){}
      return;
    }
    try{
      lastHeardWords = "";
      recognizer.start();
    }catch(_){
      feedback.textContent = "Bitte kurz warten und nochmals auf ‚ÄûSprechen‚Äú klicken.";
      feedback.className = "feedback error";
    }
  });

  checkBtn.addEventListener("click", checkAnswer);
  fallbackInput.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){ e.preventDefault(); checkAnswer(); }
  });

  function startTraining(){
    questionsDone = 0; correctAnswers = 0; wrongAnswers = 0; usedQuestions = [];
    statCorrect.textContent = "0";
    statWrong.textContent = "0";
    statTotal.textContent = String(TOTAL_QUESTIONS);
    statMode.textContent = `${GRADE_LABELS[selectedGrade]} ‚Äì ${DIFF_LABELS[selectedDifficulty]}`;

    feedback.textContent = "";
    feedback.className = "feedback";
    heardEl.textContent = "Erkannt: ‚Äî";
    expectedHint.textContent = "";

    startScreen.classList.add("hidden");
    resultScreen.classList.add("hidden");
    quizScreen.classList.remove("hidden");

    newQuestion();
  }

  function generateTimeQuestion(grade, diff){
    const hour = randomInt(1,12);
    let minute = 0;
    let label = "";

    if(grade === 2 && diff === "easy"){
      minute = pick([0,30]);
      label = "Volle und halbe Stunden";
    } else if(grade === 2 && diff === "hard"){
      minute = pick([0,5,10,15,20,25,30,35,40,45,50,55]);
      label = "Umgangssprache Mix";
    } else {
      minute = pick(SUPPORTED_MINUTES);
      label = (diff === "easy") ? "5-Minuten-Schritte" : "5-Minuten-Schritte (Mix)";
    }

    const canonical = capFirst(timeToCanonicalWords(hour, minute));
    return {
      hour, minute, label,
      canonical,
      acceptedPhrases: buildAcceptedPhrasesNormalized(canonical),
      acceptedPhrasesRaw: buildAcceptedPhrasesRawForGrammar(canonical),
      expectedHourWords: getExpectedHourWordsFromCanonical(canonical)
    };
  }

  function newQuestion(){
    feedback.textContent = "";
    feedback.className = "feedback";
    lastHeardWords = "";
    fallbackInput.value = "";
    heardEl.textContent = "Erkannt: ‚Äî";

    let q, tries = 0;
    while(true){
      q = generateTimeQuestion(selectedGrade, selectedDifficulty);
      const key = `${q.hour}-${q.minute}-${selectedGrade}-${selectedDifficulty}`;
      if(!usedQuestions.includes(key)){
        usedQuestions.push(key);
        break;
      }
      if(++tries > 400) break;
    }

    currentQuestion = q;
    variantLabel.textContent = q.label;

    drawClock(q.hour, q.minute);
    progressText.textContent = `Aufgabe ${questionsDone + 1} von ${TOTAL_QUESTIONS}`;
    expectedHint.textContent = "Beispiel richtig: " + normalizeHeardToClockWords(q.canonical);

    setGrammarForCurrentQuestion();
  }

  function checkAnswer(){
    const typed = (fallbackInput.value || "").trim();
    const heard = lastHeardWords || normalizeHeardToClockWords(typed);

    if(!heard){
      feedback.textContent = "Bitte zuerst sprechen (oder eintippen) und dann √ºberpr√ºfen.";
      feedback.className = "feedback error";
      return;
    }

    let ok = false;
    for(const exp of currentQuestion.acceptedPhrases){
      if(containsPhrase(heard, exp)){
        ok = true; break;
      }
    }

    if(ok){
      correctAnswers++;
      statCorrect.textContent = String(correctAnswers);
      feedback.textContent = "Richtig! üëç";
      feedback.className = "feedback ok";
    }else{
      wrongAnswers++;
      statWrong.textContent = String(wrongAnswers);
      feedback.textContent = "Falsch. Richtig w√§re: " + currentQuestion.acceptedPhrases[0];
      feedback.className = "feedback error";
    }

    questionsDone++;
    if(questionsDone >= TOTAL_QUESTIONS) setTimeout(endTraining, 700);
    else setTimeout(newQuestion, 700);
  }

  function endTraining(){
    quizScreen.classList.add("hidden");
    resultScreen.classList.remove("hidden");
    const quote = (correctAnswers / TOTAL_QUESTIONS * 100).toFixed(0);
    resultSummary.innerHTML =
      `Du hast <strong>${TOTAL_QUESTIONS}</strong> Uhrzeiten gel√∂st.<br>` +
      `Richtig: <strong>${correctAnswers}</strong> (${quote}%).<br>` +
      `Falsch: <strong>${wrongAnswers}</strong>.`;
  }

  // ==========================
  // Clock: no numbers, minute+hour ticks, red hour hand, blue minute hand
  // ==========================
  function drawClock(hour, minute){
    const ctx = clockCtx;
    const w = clockCanvas.width;
    const h = clockCanvas.height;
    const radius = Math.min(w,h)/2 - 10;
    const cx = w/2;
    const cy = h/2;

    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(cx,cy);

    // Face
    ctx.beginPath();
    ctx.arc(0,0,radius,0,Math.PI*2);
    ctx.fillStyle="#ffffff";
    ctx.fill();
    ctx.lineWidth=3;
    ctx.strokeStyle="#111827";
    ctx.stroke();

    // Minute ticks (60)
    for(let i=0;i<60;i++){
      const angle = (Math.PI/30)*i - Math.PI/2;
      const isHour = (i%5===0);

      const outer = radius - 6;
      const inner = radius - (isHour ? 18 : 12);

      ctx.beginPath();
      ctx.moveTo(inner*Math.cos(angle), inner*Math.sin(angle));
      ctx.lineTo(outer*Math.cos(angle), outer*Math.sin(angle));
      ctx.lineWidth = isHour ? 3 : 1.2;
      ctx.strokeStyle = "#111827";
      ctx.stroke();
    }

    // Hands
    // Minute hand (blue)
    const minuteAngle = (Math.PI/30)*minute - Math.PI/2;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo((radius-22)*Math.cos(minuteAngle), (radius-22)*Math.sin(minuteAngle));
    ctx.lineWidth=4;
    ctx.strokeStyle="#2563eb"; // blue
    ctx.lineCap="round";
    ctx.stroke();

    // Hour hand (red)
    const hourIn12 = hour % 12;
    const hourAngle = (Math.PI/6)*(hourIn12 + minute/60) - Math.PI/2;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo((radius-55)*Math.cos(hourAngle), (radius-55)*Math.sin(hourAngle));
    ctx.lineWidth=5;
    ctx.strokeStyle="#dc2626"; // red
    ctx.lineCap="round";
    ctx.stroke();

    // Center cap
    ctx.beginPath();
    ctx.arc(0,0,5,0,Math.PI*2);
    ctx.fillStyle="#111827";
    ctx.fill();

    ctx.restore();
  }

  // ==========================
  // Init
  // ==========================
  (function init(){
    statTotal.textContent = String(TOTAL_QUESTIONS);
    drawClock(12,0);
    setupSpeechRecognition();
    updateStartControls();
  })();
</script>
</body>
</html>
